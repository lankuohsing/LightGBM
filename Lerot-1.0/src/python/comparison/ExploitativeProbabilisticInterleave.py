# This file is part of Lerot.
#
# Lerot is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Lerot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Lerot.  If not, see <http://www.gnu.org/licenses/>.

# KH, 2012/06/19

import argparse
import logging

from numpy import asarray, cumsum, where
from random import random
from utils import split_arg_str, string_to_boolean

from AbstractInterleavedComparison import AbstractInterleavedComparison
from ProbabilisticInterleave import ProbabilisticInterleave


class ExploitativeProbabilisticInterleave(AbstractInterleavedComparison):
    """Probabilistic interleaving that balances exploration with exploitation,
    marginalizes over assignments."""

    def __init__(self, arg_str=None):
        self.pi = ProbabilisticInterleave(arg_str)
        if arg_str:
            parser = argparse.ArgumentParser(description="Parse arguments for "
                "interleaving method.", prog=self.__class__.__name__)
            parser.add_argument("-a", "--aggregate", choices=["expectation",
                "log-likelihood-ratio", "likelihood-ratio", "log-ratio",
                "binary"], default="expectation")
            parser.add_argument("-e", "--exploration_rate", type=float,
                required=True, help="Exploration rate, 0.5 = perfect "
                "exploration, 0.0 = perfect exploitation.")
            parser.add_argument("-b", "--biased", default="False")

            args = vars(parser.parse_known_args(split_arg_str(arg_str))[0])
            self.exploration_rate = args["exploration_rate"]
            self.aggregate = args["aggregate"]

            self.biased = string_to_boolean(args["biased"])
        else:
            raise ValueError("Configuration arguments required. Please provide"
                " at least a value for the exploration rate.")

    def _get_document_distribution(self, r1, r2):
        """Compute the combined distribution over documents. Return two lists:
        (docids, probs), where probs[i] is the probability of the document
        docids[i]."""
        docids = r1.get_ranking()
        probs = []
        for docid in docids:
            p1 = r1.get_document_probability(docid)
            p2 = r2.get_document_probability(docid)
            # always assume r1 as the exploitative ranking
            probs.append((1 - self.exploration_rate) * p1
                + self.exploration_rate * p2)
        # sort docids and probs by probability
        # the sort is stable, ties are broken according to ranking r1
        probs, docids = zip(*sorted(zip(probs, docids), reverse=True))
        probs = asarray(probs)
        docids = list(docids)
        return (docids, probs)

    def interleave(self, r1, r2, query, length):
        # compute combined probabilities
        r1.init_ranking(query)
        r2.init_ranking(query)
        length = min(r1.document_count(), r2.document_count(), length)

        l = []
        while len(l) < length:
            (docids, probs) = self._get_document_distribution(r1, r2)
            # sample from distribution without replacement
            # unless there is only one document left
            if len(docids) == 1:
                pick = docids.pop(0)
            else:
                # same as in ProbablisticRankingFunction
                cumprobs = cumsum(probs)
                pick = -1
                rand = random()  # produces a float in range [0.0, 1.0)
                for pos, cp in enumerate(cumprobs):
                    if rand < cp:
                        pick = docids.pop(pos)  # pop, because it's a list
                        break
                if (pick == -1):
                    print "Cumprobs:", cumprobs
                    print "rand", rand
                    raise Exception("Could not select document!")
                # remove picked docid from r1 and r2
                r1.rm_document(pick)
                r2.rm_document(pick)

            l.append(pick)

        return (asarray(l), (r1, r2))

    def _get_source_probability_of_list(self, l, a, query):
        p_l = 1.0
        (_, r1, r2) = a
        r1.init_ranking(query)
        r2.init_ranking(query)
        for _, doc in enumerate(l):
            p_r1 = r1.get_document_probability(doc)
            p_r2 = r2.get_document_probability(doc)
            r1.rm_document(doc)
            r2.rm_document(doc)
            p_l *= ((1 - self.exploration_rate) * p_r1 + self.exploration_rate
                * p_r2)
        return p_l

    def infer_outcome(self, l, a, c, query):
        # for prob interleave, a = (a, r1, r2)
        outcome = self.pi.infer_outcome(l, a, c, query)
        # return outcome unless bias compensation is needed
        if outcome == 0:
            return 0
        if self.biased or self.exploration_rate == 0.5:
            return outcome
        # apply importance sampling for unbiased outcomes
        target_p_list = self.pi.get_probability_of_list(l, a, query)
        source_p_list = self._get_source_probability_of_list(l, a, query)
        if target_p_list == 0 or source_p_list == 0:
            logging.warn("Encountered zero probabilities: p(l_target) = %.2f, "
                "p(l_source) = %.2f" % (target_p_list, source_p_list))
            return 0
        return outcome * target_p_list / source_p_list
